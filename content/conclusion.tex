% $Id: conclusion.tex 
% !TEX root = ../main.tex

\section{Conclusion and Future Work}
\label{sec:conclusion}

In this work, we presented \flik, a back-in-time debugger for \ac{RL} programs. The introduction of \flik 
is motivated by problems detected in \ac{RL} systems development. First, \ac{RL} programs are 
complex in terms of the interaction between the agent and the environment. Second, the computational 
complexity of the environments come with high costs of training and retraining agents whenever 
unexpected behavior is observed. 
In the former case, understanding the behavior of agents becomes more difficult for developers, as this 
comes from the interaction itself and the valuation associated with each interaction, not just the 
sequence of program instructions to follow. In the latter case, developers must unwind long iterative 
execution traces for the different episodes to identify the location or cause of the strange behavior, 
which for small \ac{RL} programs can already have over thousands of iterations. Continuously training 
the agents for debugging can be very time-consuming and use significant computational resources.

A back-in-time debugger strategy is beneficial for the scenario of \ac{RL} programs as it lets 
developers to interact with their agents directly, not just as a postmortem activity, enabling the 
opportunity to go back in the execution of a program, recover all of its state and context of execution, 
update the system's state, and observe the effect of the agent with respect to the changed state, 
generating a new execution path, without the need to stop or completely retrain agents. These features 
are desirable to tackle the problem of interaction and long execution of \ac{RL} programs. Our proposed 
debugger enables developers to inspect the state of the program in terms of variables, additionally 
providing a functionality to interact with the execution of the program going forward and backwards.

We validate a back-in-time debugger is indeed useful to identify the root cause of bugs through an 
empirical study where 27 participants used \flik in the identification of bugs for three different \ac{RL} 
programs. Most study participants managed to understand the behavior of the agent, and find the root 
cause of the bug for the three programs. Specifically, \flik proved  to be useful to find general bugs that 
an \ac{RL} program can present during development. 
Additionally, in the study we evaluated the usability of \flik as a debugging. Even though \flik is a 
console-based debugger, it allows developers to interact with a program during its execution, inspect 
the internal state of the agent, and modify its state and behavior in real-time. 

There are three important avenues of future work to improve the usability of \flik, as gathered from the 
empirical study and the development process. 

First, we want to optimize memory consumption by using layer cashing using a similar strategy to that 
used in git or docker, as a means to save states. Instead of saving the entire history of all variables 
(global and local), and all the metadata of the program for each execution point, we could 
save the changes made on the program since the last recorded history. This would optimize the 
memory usage of \flik. We envision such a change to require a more complex logic and evolving the 
design of \flik to an architecture to support the new features. 

Second, we can develop a full visual interface for \flik, following similar debugger interfaces (\eg 
VSCode or Eclipse) as pluggins to an IDE. In this way developers could easier interact with the features 
(commands) of the debugger in a more friendly way. This for example, would also open the opportunity 
to generate visualization for the different execution traces from the re-execution of parts of the program.
Improving the interface of \flik could reduced the complexity of understanding \ac{RL} program,
making it easier to navigate the code and jump back in time.

Finally, \flik could be improved by integrating visualization environments and graphs, as created with 
matplotlib or pygame, so the user could have a better understanding of the environment and the 
agent's behavior, while debugging the program.


\endinput
